/*
CDN API

API used to create and manage your CDN distributions.

API version: 1beta2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cdnbeta

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/stackitcloud/stackit-sdk-go/core/config"
	"github.com/stackitcloud/stackit-sdk-go/core/oapierror"
)

type DefaultApi interface {
	/*
		CreateDistribution Create new distribution
		CreateDistribution will create a new CDN distribution

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@return ApiCreateDistributionRequest
	*/
	CreateDistribution(ctx context.Context, projectId string) ApiCreateDistributionRequest
	/*
		CreateDistributionExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@return CreateDistributionResponse

	*/
	CreateDistributionExecute(ctx context.Context, projectId string) (*CreateDistributionResponse, error)
	/*
		DeleteCustomDomain Delete a custom domain
		Removes a custom domain


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@param domain
		@return ApiDeleteCustomDomainRequest
	*/
	DeleteCustomDomain(ctx context.Context, projectId string, distributionId string, domain string) ApiDeleteCustomDomainRequest
	/*
		DeleteCustomDomainExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@param domain
		@return DeleteCustomDomainResponse

	*/
	DeleteCustomDomainExecute(ctx context.Context, projectId string, distributionId string, domain string) (*DeleteCustomDomainResponse, error)
	/*
		DeleteDistribution Delete distribution
		DeleteDistribution accepts a project- and distribution-Id and will delete a distribution.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@return ApiDeleteDistributionRequest
	*/
	DeleteDistribution(ctx context.Context, projectId string, distributionId string) ApiDeleteDistributionRequest
	/*
		DeleteDistributionExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@return DeleteDistributionResponse

	*/
	DeleteDistributionExecute(ctx context.Context, projectId string, distributionId string) (*DeleteDistributionResponse, error)
	/*
		FindCachePaths Return Paths that were purged
		This returns paths that are present in the cache purging history.
		Only substrings of the provided input are returned.
		The response is sorted in descending order by the most recent purge.

		So, assuming you have have the following purged for a distribution
		- `/test/1` at `2025-01-01`
		- `/test/2` at `2025-01-02`
		- `/someOtherPath/1` at `2025-01-03`
		- `/test/1` at `2025-01-04`
		- `/test/3` at `2025-01-05`,
		this would return the following paths, in the following order, assuming `/te` was the search parameter:
		- `/test/3`
		- `/test/1`
		- `/test/2`


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@return ApiFindCachePathsRequest
	*/
	FindCachePaths(ctx context.Context, projectId string, distributionId string) ApiFindCachePathsRequest
	/*
		FindCachePathsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@return FindCachePathsResponse

	*/
	FindCachePathsExecute(ctx context.Context, projectId string, distributionId string) (*FindCachePathsResponse, error)
	/*
		GetCacheInfo Get Infos about the Caching State
		Return caching info metadata, which contains the last cache purging time and a history of the most recent *full* purges.

		If (and only if) you provide the path query parameter, the history will also contain granular cache purges.
		The request will not fail if no data about a path is found.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@return ApiGetCacheInfoRequest
	*/
	GetCacheInfo(ctx context.Context, projectId string, distributionId string) ApiGetCacheInfoRequest
	/*
		GetCacheInfoExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@return GetCacheInfoResponse

	*/
	GetCacheInfoExecute(ctx context.Context, projectId string, distributionId string) (*GetCacheInfoResponse, error)
	/*
		GetCustomDomain Retrieve a specific custom domain
		Returns a 200 and the custom domain if this custom domain was associated to this distribution, else 404


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@param domain
		@return ApiGetCustomDomainRequest
	*/
	GetCustomDomain(ctx context.Context, projectId string, distributionId string, domain string) ApiGetCustomDomainRequest
	/*
		GetCustomDomainExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@param domain
		@return GetCustomDomainResponse

	*/
	GetCustomDomainExecute(ctx context.Context, projectId string, distributionId string, domain string) (*GetCustomDomainResponse, error)
	/*
		GetDistribution Get distribution by Id
		This returns a specific distribution by its Id. If no distribution with the given Id exists the endpoint returns 404. Trying to get a deleted distributions also return 404.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@return ApiGetDistributionRequest
	*/
	GetDistribution(ctx context.Context, projectId string, distributionId string) ApiGetDistributionRequest
	/*
		GetDistributionExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@return GetDistributionResponse

	*/
	GetDistributionExecute(ctx context.Context, projectId string, distributionId string) (*GetDistributionResponse, error)
	/*
		GetLogs Retrieve distribution logs

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId Your CDN distribution Id
		@return ApiGetLogsRequest
	*/
	GetLogs(ctx context.Context, projectId string, distributionId string) ApiGetLogsRequest
	/*
		GetLogsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId Your CDN distribution Id
		@return GetLogsResponse

	*/
	GetLogsExecute(ctx context.Context, projectId string, distributionId string) (*GetLogsResponse, error)
	/*
		GetStatistics Retrieve the statistics of a distribution
		Returns the statistics of the distribution in the given
		time range. The response is a list of statistics records. Each record aggregates the statistics for its time interval.
		In case no statistics for a time interval exist, no record is returned.
		The time range for which statistics should be returned can be configured using query parameters.

		Timestamps are assumed to be UTC. This is especially important for the "buckets" when you, for example, return daily information. A day always starts and ends at 00:00Z.

		**Important Note:** Lower bounds are inclusive, upper bounds are exclusive. If you, for example, want a daily grouped which starts on the 1st Jan and also contains the full 10th Jan day, you would define `2025-01-01T00:00:00Z` as the lower and `2025-01-11T00:00:00Z` as the upper bound.

		The upper bound is optional. If you omit it, the API will use the start of the next interval as the upper bound.
		Example: if `interval` is `hourly`, `from` would default to the start of the next hour, if it's `daily`, `from` would default to the start of the next day, etc.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@return ApiGetStatisticsRequest
	*/
	GetStatistics(ctx context.Context, projectId string, distributionId string) ApiGetStatisticsRequest
	/*
		GetStatisticsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@return GetStatisticsResponse

	*/
	GetStatisticsExecute(ctx context.Context, projectId string, distributionId string) (*GetStatisticsResponse, error)
	/*
		ListDistributions List all distributions belonging to a specific project
		ListDistributions returns a list of all CDN distributions associated with
		a given project, ordered by their distribution Id.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@return ApiListDistributionsRequest
	*/
	ListDistributions(ctx context.Context, projectId string) ApiListDistributionsRequest
	/*
		ListDistributionsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@return ListDistributionsResponse

	*/
	ListDistributionsExecute(ctx context.Context, projectId string) (*ListDistributionsResponse, error)
	/*
		ListWafCollections List all WAF rule collections of the project
		Returns all WAF rule collections available to the project

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@return ApiListWafCollectionsRequest
	*/
	ListWafCollections(ctx context.Context, projectId string) ApiListWafCollectionsRequest
	/*
		ListWafCollectionsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@return ListWafCollectionsResponse

	*/
	ListWafCollectionsExecute(ctx context.Context, projectId string) (*ListWafCollectionsResponse, error)
	/*
		PatchDistribution Update existing distribution
		Modify a CDN distribution with a partial update. Only the fields specified in the request will be modified.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@return ApiPatchDistributionRequest
	*/
	PatchDistribution(ctx context.Context, projectId string, distributionId string) ApiPatchDistributionRequest
	/*
		PatchDistributionExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@return PatchDistributionResponse

	*/
	PatchDistributionExecute(ctx context.Context, projectId string, distributionId string) (*PatchDistributionResponse, error)
	/*
		PurgeCache Clear distribution cache
		Clear the cache for this distribution.
		All content, regardless of its staleness, will get refetched from the host.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@return ApiPurgeCacheRequest
	*/
	PurgeCache(ctx context.Context, projectId string, distributionId string) ApiPurgeCacheRequest
	/*
		PurgeCacheExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@return map[string]interface{}

	*/
	PurgeCacheExecute(ctx context.Context, projectId string, distributionId string) (map[string]interface{}, error)
	/*
		PutCustomDomain Create or update a custom domain
		Creates a new custom domain. If it already exists, this will overwrite the previous custom domain's properties.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@param domain
		@return ApiPutCustomDomainRequest
	*/
	PutCustomDomain(ctx context.Context, projectId string, distributionId string, domain string) ApiPutCustomDomainRequest
	/*
		PutCustomDomainExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Your STACKIT Project Id
		@param distributionId
		@param domain
		@return PutCustomDomainResponse

	*/
	PutCustomDomainExecute(ctx context.Context, projectId string, distributionId string, domain string) (*PutCustomDomainResponse, error)
}

type ApiCreateDistributionRequest interface {
	CreateDistributionPayload(createDistributionPayload CreateDistributionPayload) ApiCreateDistributionRequest
	Execute() (*CreateDistributionResponse, error)
}

type ApiDeleteCustomDomainRequest interface {
	IntentId(intentId string) ApiDeleteCustomDomainRequest
	Execute() (*DeleteCustomDomainResponse, error)
}

type ApiDeleteDistributionRequest interface {
	// While optional, it is greatly encouraged to provide an &#x60;intentId&#x60;.  This is used to deduplicate requests.   If multiple DELETE-Requests with the same &#x60;intentId&#x60; are received, all but the first request are dropped.
	IntentId(intentId string) ApiDeleteDistributionRequest
	Execute() (*DeleteDistributionResponse, error)
}

type ApiFindCachePathsRequest interface {
	// A substring of the search query.
	Path(path string) ApiFindCachePathsRequest
	Execute() (*FindCachePathsResponse, error)
}

type ApiGetCacheInfoRequest interface {
	PurgePath(purgePath string) ApiGetCacheInfoRequest
	Execute() (*GetCacheInfoResponse, error)
}

type ApiGetCustomDomainRequest interface {
	Execute() (*GetCustomDomainResponse, error)
}

type ApiGetDistributionRequest interface {
	// If set, the top level of a distribution contains a &#x60;waf&#x60; property, which defines the status of the waf. This includes a list of all resolved rules.
	WithWafStatus(withWafStatus bool) ApiGetDistributionRequest
	Execute() (*GetDistributionResponse, error)
}

type ApiGetLogsRequest interface {
	// the start of the time range for which logs should be returned
	From(from time.Time) ApiGetLogsRequest
	// the end of the time range for which logs should be returned. If not specified,  \&quot;now\&quot; is used.
	To(to time.Time) ApiGetLogsRequest
	// Quantifies how many log entries should be returned on this  page. Must be a natural number between 1 and 1000 (inclusive)
	PageSize(pageSize int32) ApiGetLogsRequest
	// Identifier is returned by the previous response and is used to request the next page.  As the &#x60;pageIdentifier&#x60; encodes an element, inserts during pagination will *not* shift the result. So a scenario like:   - Start listing first page - Insert new element - Start listing second page will *never* result in an element from the first page to get \&quot;pushed\&quot; to the second page, like it could  occur with basic limit + offset pagination.  The identifier should be treated as an opaque string and never modified. Only pass values returned by the API.
	PageIdentifier(pageIdentifier string) ApiGetLogsRequest
	// Sorts the log messages by a specific field. Defaults to &#x60;timestamp&#x60;.  Supported sort options: - &#x60;timestamp&#x60; - &#x60;dataCenterRegion&#x60; - &#x60;requestCountryCode&#x60; - &#x60;statusCode&#x60; - &#x60;cacheHit&#x60; - &#x60;size&#x60; - &#x60;path&#x60; - &#x60;host&#x60;
	SortBy(sortBy string) ApiGetLogsRequest
	SortOrder(sortOrder string) ApiGetLogsRequest
	// Filters by the CDN data center region that served the request. Can be combined with other filters
	DataCenterRegion(dataCenterRegion string) ApiGetLogsRequest
	// Filters by the originating country of the user request. Can be combined with other filters
	RequestCountryCode(requestCountryCode string) ApiGetLogsRequest
	// Filters by the HTTP status code returned to the client. Can be combined with other filters
	StatusCode(statusCode int32) ApiGetLogsRequest
	// Filters based on whether the request was served from the CDN cache. Can be combined with other filters
	CacheHit(cacheHit bool) ApiGetLogsRequest
	Execute() (*GetLogsResponse, error)
}

type ApiGetStatisticsRequest interface {
	// the start of the time range for which statistics should be returned
	From(from time.Time) ApiGetStatisticsRequest
	// the end of the time range for which statistics should be returned. If not specified,  the end of the current time interval is used, e.g. next day for daily,  next month for monthly, and so on.
	To(to time.Time) ApiGetStatisticsRequest
	// Over which interval should statistics be aggregated?  defaults to hourly resolution  **NOTE**: Intervals are grouped in buckets that start and end based on a day in UTC+0 time. So for the &#x60;daily&#x60; interval, the group starts (inclusive) and ends (exclusive) at &#x60;00:00Z&#x60;
	Interval(interval string) ApiGetStatisticsRequest
	Execute() (*GetStatisticsResponse, error)
}

type ApiListDistributionsRequest interface {
	// Quantifies how many distributions should be returned on this  page. Must be a natural number between 1 and 100 (inclusive)
	PageSize(pageSize int32) ApiListDistributionsRequest
	// If set, the top level of a distribution contains a &#x60;waf&#x60; property, which defines the status of the waf. This includes a list of all resolved rules.
	WithWafStatus(withWafStatus bool) ApiListDistributionsRequest
	// Identifier is returned by the previous response and is used to request the next page.  As the &#x60;pageIdentifier&#x60; encodes an element, inserts during pagination will *not* shift the result. So a scenario like:   - Start listing first page - Insert new element - Start listing second page will *never* result in an element from the first page to get \&quot;pushed\&quot; to the second page, like it could  occur with basic limit + offset pagination.  The identifier should be treated as an opaque string and never modified. Only pass values returned by the API.
	PageIdentifier(pageIdentifier string) ApiListDistributionsRequest
	// The following sort options exist. We default to &#x60;createdAt&#x60; - &#x60;id&#x60; - Sort by distribution Id using String comparison - &#x60;updatedAt&#x60; - Sort by when the distribution configuration was last modified,    for example by changing the regions or response headers - &#x60;createdAt&#x60; - Sort by when the distribution was initially created. - &#x60;originUrl&#x60; - Sort by originUrl using String comparison - &#x60;status&#x60; - Sort by distribution status, using String comparison - &#x60;originUrlRelated&#x60; - The originUrl is segmented and reversed before sorting. E.g. &#x60;www.example.com&#x60; is converted to &#x60;com.example.www&#x60; for sorting. This way, distributions pointing to the same domain trees are grouped next to each other.
	SortBy(sortBy string) ApiListDistributionsRequest
	SortOrder(sortOrder string) ApiListDistributionsRequest
	Execute() (*ListDistributionsResponse, error)
}

type ApiListWafCollectionsRequest interface {
	Execute() (*ListWafCollectionsResponse, error)
}

type ApiPatchDistributionRequest interface {
	PatchDistributionPayload(patchDistributionPayload PatchDistributionPayload) ApiPatchDistributionRequest
	Execute() (*PatchDistributionResponse, error)
}

type ApiPurgeCacheRequest interface {
	PurgeCachePayload(purgeCachePayload PurgeCachePayload) ApiPurgeCacheRequest
	Execute() (map[string]interface{}, error)
}

type ApiPutCustomDomainRequest interface {
	PutCustomDomainPayload(putCustomDomainPayload PutCustomDomainPayload) ApiPutCustomDomainRequest
	Execute() (*PutCustomDomainResponse, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type CreateDistributionRequest struct {
	ctx                       context.Context
	apiService                *DefaultApiService
	projectId                 string
	createDistributionPayload *CreateDistributionPayload
}

func (r CreateDistributionRequest) CreateDistributionPayload(createDistributionPayload CreateDistributionPayload) ApiCreateDistributionRequest {
	r.createDistributionPayload = &createDistributionPayload
	return r
}

func (r CreateDistributionRequest) Execute() (*CreateDistributionResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateDistributionResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateDistribution")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta2/projects/{projectId}/distributions"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createDistributionPayload == nil {
		return localVarReturnValue, fmt.Errorf("createDistributionPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createDistributionPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v GenericJsonResponse
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateDistribution: Create new distribution

CreateDistribution will create a new CDN distribution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Your STACKIT Project Id
	@return ApiCreateDistributionRequest
*/
func (a *APIClient) CreateDistribution(ctx context.Context, projectId string) ApiCreateDistributionRequest {
	return CreateDistributionRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) CreateDistributionExecute(ctx context.Context, projectId string) (*CreateDistributionResponse, error) {
	r := CreateDistributionRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type DeleteCustomDomainRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	distributionId string
	domain         string
	intentId       *string
}

func (r DeleteCustomDomainRequest) IntentId(intentId string) ApiDeleteCustomDomainRequest {
	r.intentId = &intentId
	return r
}

func (r DeleteCustomDomainRequest) Execute() (*DeleteCustomDomainResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteCustomDomainResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteCustomDomain")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta2/projects/{projectId}/distributions/{distributionId}/customDomains/{domain}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"distributionId"+"}", url.PathEscape(ParameterValueToString(r.distributionId, "distributionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"domain"+"}", url.PathEscape(ParameterValueToString(r.domain, "domain")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.domain) > 72 {
		return localVarReturnValue, fmt.Errorf("domain must have less than 72 elements")
	}

	if r.intentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "intentId", r.intentId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v GenericJsonResponse
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteCustomDomain: Delete a custom domain

# Removes a custom domain

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Your STACKIT Project Id
	@param distributionId
	@param domain
	@return ApiDeleteCustomDomainRequest
*/
func (a *APIClient) DeleteCustomDomain(ctx context.Context, projectId string, distributionId string, domain string) ApiDeleteCustomDomainRequest {
	return DeleteCustomDomainRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
		domain:         domain,
	}
}

func (a *APIClient) DeleteCustomDomainExecute(ctx context.Context, projectId string, distributionId string, domain string) (*DeleteCustomDomainResponse, error) {
	r := DeleteCustomDomainRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
		domain:         domain,
	}
	return r.Execute()
}

type DeleteDistributionRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	distributionId string
	intentId       *string
}

// While optional, it is greatly encouraged to provide an &#x60;intentId&#x60;.  This is used to deduplicate requests.   If multiple DELETE-Requests with the same &#x60;intentId&#x60; are received, all but the first request are dropped.

func (r DeleteDistributionRequest) IntentId(intentId string) ApiDeleteDistributionRequest {
	r.intentId = &intentId
	return r
}

func (r DeleteDistributionRequest) Execute() (*DeleteDistributionResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteDistributionResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteDistribution")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta2/projects/{projectId}/distributions/{distributionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"distributionId"+"}", url.PathEscape(ParameterValueToString(r.distributionId, "distributionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.intentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "intentId", r.intentId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v GenericJsonResponse
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteDistribution: Delete distribution

DeleteDistribution accepts a project- and distribution-Id and will delete a distribution.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Your STACKIT Project Id
	@param distributionId
	@return ApiDeleteDistributionRequest
*/
func (a *APIClient) DeleteDistribution(ctx context.Context, projectId string, distributionId string) ApiDeleteDistributionRequest {
	return DeleteDistributionRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
	}
}

func (a *APIClient) DeleteDistributionExecute(ctx context.Context, projectId string, distributionId string) (*DeleteDistributionResponse, error) {
	r := DeleteDistributionRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
	}
	return r.Execute()
}

type FindCachePathsRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	distributionId string
	path           *string
}

// A substring of the search query.

func (r FindCachePathsRequest) Path(path string) ApiFindCachePathsRequest {
	r.path = &path
	return r
}

func (r FindCachePathsRequest) Execute() (*FindCachePathsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FindCachePathsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FindCachePaths")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta2/projects/{projectId}/distributions/{distributionId}/cache/paths"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"distributionId"+"}", url.PathEscape(ParameterValueToString(r.distributionId, "distributionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, fmt.Errorf("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v GenericJsonResponse
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
FindCachePaths: Return Paths that were purged

This returns paths that are present in the cache purging history.
Only substrings of the provided input are returned.
The response is sorted in descending order by the most recent purge.

So, assuming you have have the following purged for a distribution
- `/test/1` at `2025-01-01`
- `/test/2` at `2025-01-02`
- `/someOtherPath/1` at `2025-01-03`
- `/test/1` at `2025-01-04`
- `/test/3` at `2025-01-05`,
this would return the following paths, in the following order, assuming `/te` was the search parameter:
- `/test/3`
- `/test/1`
- `/test/2`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Your STACKIT Project Id
	@param distributionId
	@return ApiFindCachePathsRequest
*/
func (a *APIClient) FindCachePaths(ctx context.Context, projectId string, distributionId string) ApiFindCachePathsRequest {
	return FindCachePathsRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
	}
}

func (a *APIClient) FindCachePathsExecute(ctx context.Context, projectId string, distributionId string) (*FindCachePathsResponse, error) {
	r := FindCachePathsRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
	}
	return r.Execute()
}

type GetCacheInfoRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	distributionId string
	purgePath      *string
}

func (r GetCacheInfoRequest) PurgePath(purgePath string) ApiGetCacheInfoRequest {
	r.purgePath = &purgePath
	return r
}

func (r GetCacheInfoRequest) Execute() (*GetCacheInfoResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetCacheInfoResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetCacheInfo")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta2/projects/{projectId}/distributions/{distributionId}/cache"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"distributionId"+"}", url.PathEscape(ParameterValueToString(r.distributionId, "distributionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.purgePath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purgePath", r.purgePath, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v GenericJsonResponse
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetCacheInfo: Get Infos about the Caching State

Return caching info metadata, which contains the last cache purging time and a history of the most recent *full* purges.

If (and only if) you provide the path query parameter, the history will also contain granular cache purges.
The request will not fail if no data about a path is found.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Your STACKIT Project Id
	@param distributionId
	@return ApiGetCacheInfoRequest
*/
func (a *APIClient) GetCacheInfo(ctx context.Context, projectId string, distributionId string) ApiGetCacheInfoRequest {
	return GetCacheInfoRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
	}
}

func (a *APIClient) GetCacheInfoExecute(ctx context.Context, projectId string, distributionId string) (*GetCacheInfoResponse, error) {
	r := GetCacheInfoRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
	}
	return r.Execute()
}

type GetCustomDomainRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	distributionId string
	domain         string
}

func (r GetCustomDomainRequest) Execute() (*GetCustomDomainResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetCustomDomainResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetCustomDomain")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta2/projects/{projectId}/distributions/{distributionId}/customDomains/{domain}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"distributionId"+"}", url.PathEscape(ParameterValueToString(r.distributionId, "distributionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"domain"+"}", url.PathEscape(ParameterValueToString(r.domain, "domain")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.domain) > 72 {
		return localVarReturnValue, fmt.Errorf("domain must have less than 72 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v GenericJsonResponse
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetCustomDomain: Retrieve a specific custom domain

# Returns a 200 and the custom domain if this custom domain was associated to this distribution, else 404

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Your STACKIT Project Id
	@param distributionId
	@param domain
	@return ApiGetCustomDomainRequest
*/
func (a *APIClient) GetCustomDomain(ctx context.Context, projectId string, distributionId string, domain string) ApiGetCustomDomainRequest {
	return GetCustomDomainRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
		domain:         domain,
	}
}

func (a *APIClient) GetCustomDomainExecute(ctx context.Context, projectId string, distributionId string, domain string) (*GetCustomDomainResponse, error) {
	r := GetCustomDomainRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
		domain:         domain,
	}
	return r.Execute()
}

type GetDistributionRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	distributionId string
	withWafStatus  *bool
}

// If set, the top level of a distribution contains a &#x60;waf&#x60; property, which defines the status of the waf. This includes a list of all resolved rules.

func (r GetDistributionRequest) WithWafStatus(withWafStatus bool) ApiGetDistributionRequest {
	r.withWafStatus = &withWafStatus
	return r
}

func (r GetDistributionRequest) Execute() (*GetDistributionResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDistributionResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetDistribution")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta2/projects/{projectId}/distributions/{distributionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"distributionId"+"}", url.PathEscape(ParameterValueToString(r.distributionId, "distributionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withWafStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withWafStatus", r.withWafStatus, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v GenericJsonResponse
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetDistribution: Get distribution by Id

This returns a specific distribution by its Id. If no distribution with the given Id exists the endpoint returns 404. Trying to get a deleted distributions also return 404.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Your STACKIT Project Id
	@param distributionId
	@return ApiGetDistributionRequest
*/
func (a *APIClient) GetDistribution(ctx context.Context, projectId string, distributionId string) ApiGetDistributionRequest {
	return GetDistributionRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
	}
}

func (a *APIClient) GetDistributionExecute(ctx context.Context, projectId string, distributionId string) (*GetDistributionResponse, error) {
	r := GetDistributionRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
	}
	return r.Execute()
}

type GetLogsRequest struct {
	ctx                context.Context
	apiService         *DefaultApiService
	projectId          string
	distributionId     string
	from               *time.Time
	to                 *time.Time
	pageSize           *int32
	pageIdentifier     *string
	sortBy             *string
	sortOrder          *string
	dataCenterRegion   *string
	requestCountryCode *string
	statusCode         *int32
	cacheHit           *bool
}

// the start of the time range for which logs should be returned

func (r GetLogsRequest) From(from time.Time) ApiGetLogsRequest {
	r.from = &from
	return r
}

// the end of the time range for which logs should be returned. If not specified,  \&quot;now\&quot; is used.

func (r GetLogsRequest) To(to time.Time) ApiGetLogsRequest {
	r.to = &to
	return r
}

// Quantifies how many log entries should be returned on this  page. Must be a natural number between 1 and 1000 (inclusive)

func (r GetLogsRequest) PageSize(pageSize int32) ApiGetLogsRequest {
	r.pageSize = &pageSize
	return r
}

// Identifier is returned by the previous response and is used to request the next page.  As the &#x60;pageIdentifier&#x60; encodes an element, inserts during pagination will *not* shift the result. So a scenario like:   - Start listing first page - Insert new element - Start listing second page will *never* result in an element from the first page to get \&quot;pushed\&quot; to the second page, like it could  occur with basic limit + offset pagination.  The identifier should be treated as an opaque string and never modified. Only pass values returned by the API.

func (r GetLogsRequest) PageIdentifier(pageIdentifier string) ApiGetLogsRequest {
	r.pageIdentifier = &pageIdentifier
	return r
}

// Sorts the log messages by a specific field. Defaults to &#x60;timestamp&#x60;.  Supported sort options: - &#x60;timestamp&#x60; - &#x60;dataCenterRegion&#x60; - &#x60;requestCountryCode&#x60; - &#x60;statusCode&#x60; - &#x60;cacheHit&#x60; - &#x60;size&#x60; - &#x60;path&#x60; - &#x60;host&#x60;

func (r GetLogsRequest) SortBy(sortBy string) ApiGetLogsRequest {
	r.sortBy = &sortBy
	return r
}

func (r GetLogsRequest) SortOrder(sortOrder string) ApiGetLogsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Filters by the CDN data center region that served the request. Can be combined with other filters

func (r GetLogsRequest) DataCenterRegion(dataCenterRegion string) ApiGetLogsRequest {
	r.dataCenterRegion = &dataCenterRegion
	return r
}

// Filters by the originating country of the user request. Can be combined with other filters

func (r GetLogsRequest) RequestCountryCode(requestCountryCode string) ApiGetLogsRequest {
	r.requestCountryCode = &requestCountryCode
	return r
}

// Filters by the HTTP status code returned to the client. Can be combined with other filters

func (r GetLogsRequest) StatusCode(statusCode int32) ApiGetLogsRequest {
	r.statusCode = &statusCode
	return r
}

// Filters based on whether the request was served from the CDN cache. Can be combined with other filters

func (r GetLogsRequest) CacheHit(cacheHit bool) ApiGetLogsRequest {
	r.cacheHit = &cacheHit
	return r
}

func (r GetLogsRequest) Execute() (*GetLogsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetLogsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetLogs")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta2/projects/{projectId}/distributions/{distributionId}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"distributionId"+"}", url.PathEscape(ParameterValueToString(r.distributionId, "distributionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.pageIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageIdentifier", r.pageIdentifier, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.dataCenterRegion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataCenterRegion", r.dataCenterRegion, "")
	}
	if r.requestCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requestCountryCode", r.requestCountryCode, "")
	}
	if r.statusCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statusCode", r.statusCode, "")
	}
	if r.cacheHit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cacheHit", r.cacheHit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v GenericJsonResponse
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetLogs: Retrieve distribution logs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Your STACKIT Project Id
	@param distributionId Your CDN distribution Id
	@return ApiGetLogsRequest
*/
func (a *APIClient) GetLogs(ctx context.Context, projectId string, distributionId string) ApiGetLogsRequest {
	return GetLogsRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
	}
}

func (a *APIClient) GetLogsExecute(ctx context.Context, projectId string, distributionId string) (*GetLogsResponse, error) {
	r := GetLogsRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
	}
	return r.Execute()
}

type GetStatisticsRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	distributionId string
	from           *time.Time
	to             *time.Time
	interval       *string
}

// the start of the time range for which statistics should be returned

func (r GetStatisticsRequest) From(from time.Time) ApiGetStatisticsRequest {
	r.from = &from
	return r
}

// the end of the time range for which statistics should be returned. If not specified,  the end of the current time interval is used, e.g. next day for daily,  next month for monthly, and so on.

func (r GetStatisticsRequest) To(to time.Time) ApiGetStatisticsRequest {
	r.to = &to
	return r
}

// Over which interval should statistics be aggregated?  defaults to hourly resolution  **NOTE**: Intervals are grouped in buckets that start and end based on a day in UTC+0 time. So for the &#x60;daily&#x60; interval, the group starts (inclusive) and ends (exclusive) at &#x60;00:00Z&#x60;

func (r GetStatisticsRequest) Interval(interval string) ApiGetStatisticsRequest {
	r.interval = &interval
	return r
}

func (r GetStatisticsRequest) Execute() (*GetStatisticsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetStatisticsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetStatistics")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta2/projects/{projectId}/distributions/{distributionId}/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"distributionId"+"}", url.PathEscape(ParameterValueToString(r.distributionId, "distributionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.from == nil {
		return localVarReturnValue, fmt.Errorf("from is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	}
	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v GenericJsonResponse
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetStatistics: Retrieve the statistics of a distribution

Returns the statistics of the distribution in the given
time range. The response is a list of statistics records. Each record aggregates the statistics for its time interval.
In case no statistics for a time interval exist, no record is returned.
The time range for which statistics should be returned can be configured using query parameters.

Timestamps are assumed to be UTC. This is especially important for the "buckets" when you, for example, return daily information. A day always starts and ends at 00:00Z.

**Important Note:** Lower bounds are inclusive, upper bounds are exclusive. If you, for example, want a daily grouped which starts on the 1st Jan and also contains the full 10th Jan day, you would define `2025-01-01T00:00:00Z` as the lower and `2025-01-11T00:00:00Z` as the upper bound.

The upper bound is optional. If you omit it, the API will use the start of the next interval as the upper bound.
Example: if `interval` is `hourly`, `from` would default to the start of the next hour, if it's `daily`, `from` would default to the start of the next day, etc.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Your STACKIT Project Id
	@param distributionId
	@return ApiGetStatisticsRequest
*/
func (a *APIClient) GetStatistics(ctx context.Context, projectId string, distributionId string) ApiGetStatisticsRequest {
	return GetStatisticsRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
	}
}

func (a *APIClient) GetStatisticsExecute(ctx context.Context, projectId string, distributionId string) (*GetStatisticsResponse, error) {
	r := GetStatisticsRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
	}
	return r.Execute()
}

type ListDistributionsRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	pageSize       *int32
	withWafStatus  *bool
	pageIdentifier *string
	sortBy         *string
	sortOrder      *string
}

// Quantifies how many distributions should be returned on this  page. Must be a natural number between 1 and 100 (inclusive)

func (r ListDistributionsRequest) PageSize(pageSize int32) ApiListDistributionsRequest {
	r.pageSize = &pageSize
	return r
}

// If set, the top level of a distribution contains a &#x60;waf&#x60; property, which defines the status of the waf. This includes a list of all resolved rules.

func (r ListDistributionsRequest) WithWafStatus(withWafStatus bool) ApiListDistributionsRequest {
	r.withWafStatus = &withWafStatus
	return r
}

// Identifier is returned by the previous response and is used to request the next page.  As the &#x60;pageIdentifier&#x60; encodes an element, inserts during pagination will *not* shift the result. So a scenario like:   - Start listing first page - Insert new element - Start listing second page will *never* result in an element from the first page to get \&quot;pushed\&quot; to the second page, like it could  occur with basic limit + offset pagination.  The identifier should be treated as an opaque string and never modified. Only pass values returned by the API.

func (r ListDistributionsRequest) PageIdentifier(pageIdentifier string) ApiListDistributionsRequest {
	r.pageIdentifier = &pageIdentifier
	return r
}

// The following sort options exist. We default to &#x60;createdAt&#x60; - &#x60;id&#x60; - Sort by distribution Id using String comparison - &#x60;updatedAt&#x60; - Sort by when the distribution configuration was last modified,    for example by changing the regions or response headers - &#x60;createdAt&#x60; - Sort by when the distribution was initially created. - &#x60;originUrl&#x60; - Sort by originUrl using String comparison - &#x60;status&#x60; - Sort by distribution status, using String comparison - &#x60;originUrlRelated&#x60; - The originUrl is segmented and reversed before sorting. E.g. &#x60;www.example.com&#x60; is converted to &#x60;com.example.www&#x60; for sorting. This way, distributions pointing to the same domain trees are grouped next to each other.

func (r ListDistributionsRequest) SortBy(sortBy string) ApiListDistributionsRequest {
	r.sortBy = &sortBy
	return r
}

func (r ListDistributionsRequest) SortOrder(sortOrder string) ApiListDistributionsRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ListDistributionsRequest) Execute() (*ListDistributionsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListDistributionsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListDistributions")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta2/projects/{projectId}/distributions"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.withWafStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withWafStatus", r.withWafStatus, "")
	}
	if r.pageIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageIdentifier", r.pageIdentifier, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v GenericJsonResponse
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListDistributions: List all distributions belonging to a specific project

ListDistributions returns a list of all CDN distributions associated with
a given project, ordered by their distribution Id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Your STACKIT Project Id
	@return ApiListDistributionsRequest
*/
func (a *APIClient) ListDistributions(ctx context.Context, projectId string) ApiListDistributionsRequest {
	return ListDistributionsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) ListDistributionsExecute(ctx context.Context, projectId string) (*ListDistributionsResponse, error) {
	r := ListDistributionsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type ListWafCollectionsRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
}

func (r ListWafCollectionsRequest) Execute() (*ListWafCollectionsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListWafCollectionsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListWafCollections")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta2/projects/{projectId}/waf/collections"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v GenericJsonResponse
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListWafCollections: List all WAF rule collections of the project

Returns all WAF rule collections available to the project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Your STACKIT Project Id
	@return ApiListWafCollectionsRequest
*/
func (a *APIClient) ListWafCollections(ctx context.Context, projectId string) ApiListWafCollectionsRequest {
	return ListWafCollectionsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) ListWafCollectionsExecute(ctx context.Context, projectId string) (*ListWafCollectionsResponse, error) {
	r := ListWafCollectionsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type PatchDistributionRequest struct {
	ctx                      context.Context
	apiService               *DefaultApiService
	projectId                string
	distributionId           string
	patchDistributionPayload *PatchDistributionPayload
}

func (r PatchDistributionRequest) PatchDistributionPayload(patchDistributionPayload PatchDistributionPayload) ApiPatchDistributionRequest {
	r.patchDistributionPayload = &patchDistributionPayload
	return r
}

func (r PatchDistributionRequest) Execute() (*PatchDistributionResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PatchDistributionResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PatchDistribution")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta2/projects/{projectId}/distributions/{distributionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"distributionId"+"}", url.PathEscape(ParameterValueToString(r.distributionId, "distributionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchDistributionPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v GenericJsonResponse
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
PatchDistribution: Update existing distribution

Modify a CDN distribution with a partial update. Only the fields specified in the request will be modified.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Your STACKIT Project Id
	@param distributionId
	@return ApiPatchDistributionRequest
*/
func (a *APIClient) PatchDistribution(ctx context.Context, projectId string, distributionId string) ApiPatchDistributionRequest {
	return PatchDistributionRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
	}
}

func (a *APIClient) PatchDistributionExecute(ctx context.Context, projectId string, distributionId string) (*PatchDistributionResponse, error) {
	r := PatchDistributionRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
	}
	return r.Execute()
}

type PurgeCacheRequest struct {
	ctx               context.Context
	apiService        *DefaultApiService
	projectId         string
	distributionId    string
	purgeCachePayload *PurgeCachePayload
}

func (r PurgeCacheRequest) PurgeCachePayload(purgeCachePayload PurgeCachePayload) ApiPurgeCacheRequest {
	r.purgeCachePayload = &purgeCachePayload
	return r
}

func (r PurgeCacheRequest) Execute() (map[string]interface{}, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PurgeCache")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta2/projects/{projectId}/distributions/{distributionId}/cache/purge"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"distributionId"+"}", url.PathEscape(ParameterValueToString(r.distributionId, "distributionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.purgeCachePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v GenericJsonResponse
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
PurgeCache: Clear distribution cache

Clear the cache for this distribution.
All content, regardless of its staleness, will get refetched from the host.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Your STACKIT Project Id
	@param distributionId
	@return ApiPurgeCacheRequest
*/
func (a *APIClient) PurgeCache(ctx context.Context, projectId string, distributionId string) ApiPurgeCacheRequest {
	return PurgeCacheRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
	}
}

func (a *APIClient) PurgeCacheExecute(ctx context.Context, projectId string, distributionId string) (map[string]interface{}, error) {
	r := PurgeCacheRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
	}
	return r.Execute()
}

type PutCustomDomainRequest struct {
	ctx                    context.Context
	apiService             *DefaultApiService
	projectId              string
	distributionId         string
	domain                 string
	putCustomDomainPayload *PutCustomDomainPayload
}

func (r PutCustomDomainRequest) PutCustomDomainPayload(putCustomDomainPayload PutCustomDomainPayload) ApiPutCustomDomainRequest {
	r.putCustomDomainPayload = &putCustomDomainPayload
	return r
}

func (r PutCustomDomainRequest) Execute() (*PutCustomDomainResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PutCustomDomainResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PutCustomDomain")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta2/projects/{projectId}/distributions/{distributionId}/customDomains/{domain}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"distributionId"+"}", url.PathEscape(ParameterValueToString(r.distributionId, "distributionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"domain"+"}", url.PathEscape(ParameterValueToString(r.domain, "domain")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.domain) > 72 {
		return localVarReturnValue, fmt.Errorf("domain must have less than 72 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.putCustomDomainPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericJsonResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v GenericJsonResponse
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
PutCustomDomain: Create or update a custom domain

Creates a new custom domain. If it already exists, this will overwrite the previous custom domain's properties.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Your STACKIT Project Id
	@param distributionId
	@param domain
	@return ApiPutCustomDomainRequest
*/
func (a *APIClient) PutCustomDomain(ctx context.Context, projectId string, distributionId string, domain string) ApiPutCustomDomainRequest {
	return PutCustomDomainRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
		domain:         domain,
	}
}

func (a *APIClient) PutCustomDomainExecute(ctx context.Context, projectId string, distributionId string, domain string) (*PutCustomDomainResponse, error) {
	r := PutCustomDomainRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		distributionId: distributionId,
		domain:         domain,
	}
	return r.Execute()
}
