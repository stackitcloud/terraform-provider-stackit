/*
STACKIT Application Load Balancer API

### DEPRECATED! This API offers an interface to provision and manage load balancing servers in your STACKIT project. It also has the possibility of pooling target servers for load balancing purposes.  For each application load balancer provided, two VMs are deployed in your OpenStack project subject to a fee.

API version: 2beta2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package albbeta

import (
	"encoding/json"
	"fmt"
)

// checks if the LoadBalancerError type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &LoadBalancerError{}

/*
	types and functions for description
*/

// isNotNullableString
type LoadBalancerErrorGetDescriptionAttributeType = *string

func getLoadBalancerErrorGetDescriptionAttributeTypeOk(arg LoadBalancerErrorGetDescriptionAttributeType) (ret LoadBalancerErrorGetDescriptionRetType, ok bool) {
	if arg == nil {
		return ret, false
	}
	return *arg, true
}

func setLoadBalancerErrorGetDescriptionAttributeType(arg *LoadBalancerErrorGetDescriptionAttributeType, val LoadBalancerErrorGetDescriptionRetType) {
	*arg = &val
}

type LoadBalancerErrorGetDescriptionArgType = string
type LoadBalancerErrorGetDescriptionRetType = string

/*
	types and functions for type
*/

// isEnum

// LoadBalancerErrorTypes The error type specifies which part of the application load balancer encountered the error. I.e. the API will not check if a provided public IP is actually available in the project. Instead the application load balancer with try to use the provided IP and if not available reports TYPE_FIP_NOT_CONFIGURED error.
// value type for enums
type LoadBalancerErrorTypes string

// List of Type
const (
	LOADBALANCERERRORTYPE_UNSPECIFIED                 LoadBalancerErrorTypes = "TYPE_UNSPECIFIED"
	LOADBALANCERERRORTYPE_INTERNAL                    LoadBalancerErrorTypes = "TYPE_INTERNAL"
	LOADBALANCERERRORTYPE_QUOTA_SECGROUP_EXCEEDED     LoadBalancerErrorTypes = "TYPE_QUOTA_SECGROUP_EXCEEDED"
	LOADBALANCERERRORTYPE_QUOTA_SECGROUPRULE_EXCEEDED LoadBalancerErrorTypes = "TYPE_QUOTA_SECGROUPRULE_EXCEEDED"
	LOADBALANCERERRORTYPE_PORT_NOT_CONFIGURED         LoadBalancerErrorTypes = "TYPE_PORT_NOT_CONFIGURED"
	LOADBALANCERERRORTYPE_FIP_NOT_CONFIGURED          LoadBalancerErrorTypes = "TYPE_FIP_NOT_CONFIGURED"
	LOADBALANCERERRORTYPE_TARGET_NOT_ACTIVE           LoadBalancerErrorTypes = "TYPE_TARGET_NOT_ACTIVE"
	LOADBALANCERERRORTYPE_METRICS_MISCONFIGURED       LoadBalancerErrorTypes = "TYPE_METRICS_MISCONFIGURED"
	LOADBALANCERERRORTYPE_LOGS_MISCONFIGURED          LoadBalancerErrorTypes = "TYPE_LOGS_MISCONFIGURED"
)

// All allowed values of LoadBalancerError enum
var AllowedLoadBalancerErrorTypesEnumValues = []LoadBalancerErrorTypes{
	"TYPE_UNSPECIFIED",
	"TYPE_INTERNAL",
	"TYPE_QUOTA_SECGROUP_EXCEEDED",
	"TYPE_QUOTA_SECGROUPRULE_EXCEEDED",
	"TYPE_PORT_NOT_CONFIGURED",
	"TYPE_FIP_NOT_CONFIGURED",
	"TYPE_TARGET_NOT_ACTIVE",
	"TYPE_METRICS_MISCONFIGURED",
	"TYPE_LOGS_MISCONFIGURED",
}

func (v *LoadBalancerErrorTypes) UnmarshalJSON(src []byte) error {
	// use a type alias to prevent infinite recursion during unmarshal,
	// see https://biscuit.ninja/posts/go-avoid-an-infitine-loop-with-custom-json-unmarshallers
	type TmpJson LoadBalancerErrorTypes
	var value TmpJson
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	// Allow unmarshalling zero value for testing purposes
	var zeroValue TmpJson
	if value == zeroValue {
		return nil
	}
	enumTypeValue := LoadBalancerErrorTypes(value)
	for _, existing := range AllowedLoadBalancerErrorTypesEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid LoadBalancerError", value)
}

// NewLoadBalancerErrorTypesFromValue returns a pointer to a valid LoadBalancerErrorTypes
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewLoadBalancerErrorTypesFromValue(v LoadBalancerErrorTypes) (*LoadBalancerErrorTypes, error) {
	ev := LoadBalancerErrorTypes(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for LoadBalancerErrorTypes: valid values are %v", v, AllowedLoadBalancerErrorTypesEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v LoadBalancerErrorTypes) IsValid() bool {
	for _, existing := range AllowedLoadBalancerErrorTypesEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to TypeTypes value
func (v LoadBalancerErrorTypes) Ptr() *LoadBalancerErrorTypes {
	return &v
}

type NullableLoadBalancerErrorTypes struct {
	value *LoadBalancerErrorTypes
	isSet bool
}

func (v NullableLoadBalancerErrorTypes) Get() *LoadBalancerErrorTypes {
	return v.value
}

func (v *NullableLoadBalancerErrorTypes) Set(val *LoadBalancerErrorTypes) {
	v.value = val
	v.isSet = true
}

func (v NullableLoadBalancerErrorTypes) IsSet() bool {
	return v.isSet
}

func (v *NullableLoadBalancerErrorTypes) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableLoadBalancerErrorTypes(val *LoadBalancerErrorTypes) *NullableLoadBalancerErrorTypes {
	return &NullableLoadBalancerErrorTypes{value: val, isSet: true}
}

func (v NullableLoadBalancerErrorTypes) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableLoadBalancerErrorTypes) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

type LoadBalancerErrorGetTypeAttributeType = *LoadBalancerErrorTypes
type LoadBalancerErrorGetTypeArgType = LoadBalancerErrorTypes
type LoadBalancerErrorGetTypeRetType = LoadBalancerErrorTypes

func getLoadBalancerErrorGetTypeAttributeTypeOk(arg LoadBalancerErrorGetTypeAttributeType) (ret LoadBalancerErrorGetTypeRetType, ok bool) {
	if arg == nil {
		return ret, false
	}
	return *arg, true
}

func setLoadBalancerErrorGetTypeAttributeType(arg *LoadBalancerErrorGetTypeAttributeType, val LoadBalancerErrorGetTypeRetType) {
	*arg = &val
}

// LoadBalancerError struct for LoadBalancerError
type LoadBalancerError struct {
	// The error description contains additional helpful user information to fix the error state of the application load balancer. For example the IP 45.135.247.139 does not exist in the project, then the description will report: Floating IP \"45.135.247.139\" could not be found.
	Description LoadBalancerErrorGetDescriptionAttributeType `json:"description,omitempty"`
	// The error type specifies which part of the application load balancer encountered the error. I.e. the API will not check if a provided public IP is actually available in the project. Instead the application load balancer with try to use the provided IP and if not available reports TYPE_FIP_NOT_CONFIGURED error.
	Type LoadBalancerErrorGetTypeAttributeType `json:"type,omitempty"`
}

// NewLoadBalancerError instantiates a new LoadBalancerError object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewLoadBalancerError() *LoadBalancerError {
	this := LoadBalancerError{}
	return &this
}

// NewLoadBalancerErrorWithDefaults instantiates a new LoadBalancerError object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewLoadBalancerErrorWithDefaults() *LoadBalancerError {
	this := LoadBalancerError{}
	return &this
}

// GetDescription returns the Description field value if set, zero value otherwise.
func (o *LoadBalancerError) GetDescription() (res LoadBalancerErrorGetDescriptionRetType) {
	res, _ = o.GetDescriptionOk()
	return
}

// GetDescriptionOk returns a tuple with the Description field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *LoadBalancerError) GetDescriptionOk() (ret LoadBalancerErrorGetDescriptionRetType, ok bool) {
	return getLoadBalancerErrorGetDescriptionAttributeTypeOk(o.Description)
}

// HasDescription returns a boolean if a field has been set.
func (o *LoadBalancerError) HasDescription() bool {
	_, ok := o.GetDescriptionOk()
	return ok
}

// SetDescription gets a reference to the given string and assigns it to the Description field.
func (o *LoadBalancerError) SetDescription(v LoadBalancerErrorGetDescriptionRetType) {
	setLoadBalancerErrorGetDescriptionAttributeType(&o.Description, v)
}

// GetType returns the Type field value if set, zero value otherwise.
func (o *LoadBalancerError) GetType() (res LoadBalancerErrorGetTypeRetType) {
	res, _ = o.GetTypeOk()
	return
}

// GetTypeOk returns a tuple with the Type field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *LoadBalancerError) GetTypeOk() (ret LoadBalancerErrorGetTypeRetType, ok bool) {
	return getLoadBalancerErrorGetTypeAttributeTypeOk(o.Type)
}

// HasType returns a boolean if a field has been set.
func (o *LoadBalancerError) HasType() bool {
	_, ok := o.GetTypeOk()
	return ok
}

// SetType gets a reference to the given string and assigns it to the Type field.
func (o *LoadBalancerError) SetType(v LoadBalancerErrorGetTypeRetType) {
	setLoadBalancerErrorGetTypeAttributeType(&o.Type, v)
}

func (o LoadBalancerError) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if val, ok := getLoadBalancerErrorGetDescriptionAttributeTypeOk(o.Description); ok {
		toSerialize["Description"] = val
	}
	if val, ok := getLoadBalancerErrorGetTypeAttributeTypeOk(o.Type); ok {
		toSerialize["Type"] = val
	}
	return toSerialize, nil
}

type NullableLoadBalancerError struct {
	value *LoadBalancerError
	isSet bool
}

func (v NullableLoadBalancerError) Get() *LoadBalancerError {
	return v.value
}

func (v *NullableLoadBalancerError) Set(val *LoadBalancerError) {
	v.value = val
	v.isSet = true
}

func (v NullableLoadBalancerError) IsSet() bool {
	return v.isSet
}

func (v *NullableLoadBalancerError) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableLoadBalancerError(val *LoadBalancerError) *NullableLoadBalancerError {
	return &NullableLoadBalancerError{value: val, isSet: true}
}

func (v NullableLoadBalancerError) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableLoadBalancerError) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
