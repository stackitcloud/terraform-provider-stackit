/*
STACKIT Logs API

This API provides endpoints for managing STACKIT Logs.

API version: 1alpha.0.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package logsalpha

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/stackitcloud/stackit-sdk-go/core/config"
	"github.com/stackitcloud/stackit-sdk-go/core/oapierror"
)

type DefaultApi interface {
	/*
		CreateAccessToken Create Access Token
		Create a new Logs instance access token

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@return ApiCreateAccessTokenRequest
	*/
	CreateAccessToken(ctx context.Context, projectId string, regionId string, instanceId string) ApiCreateAccessTokenRequest
	/*
		CreateAccessTokenExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@return AccessToken

	*/
	CreateAccessTokenExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*AccessToken, error)
	/*
		CreateLogsInstance Create Logs instance
		Creates a new Logs instance within the project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@return ApiCreateLogsInstanceRequest
	*/
	CreateLogsInstance(ctx context.Context, projectId string, regionId string) ApiCreateLogsInstanceRequest
	/*
		CreateLogsInstanceExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@return LogsInstance

	*/
	CreateLogsInstanceExecute(ctx context.Context, projectId string, regionId string) (*LogsInstance, error)
	/*
		DeleteAccessToken Delete Access Token
		Deletes a Logs instance access token

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@param tId The access token UUID.
		@return ApiDeleteAccessTokenRequest
	*/
	DeleteAccessToken(ctx context.Context, projectId string, regionId string, instanceId string, tId string) ApiDeleteAccessTokenRequest
	/*
		DeleteAccessTokenExecute executes the request

	*/
	DeleteAccessTokenExecute(ctx context.Context, projectId string, regionId string, instanceId string, tId string) error
	/*
		DeleteAllAccessTokens Delete All Access Tokens
		Deletes all access tokens available for a Logs instance

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@return ApiDeleteAllAccessTokensRequest
	*/
	DeleteAllAccessTokens(ctx context.Context, projectId string, regionId string, instanceId string) ApiDeleteAllAccessTokensRequest
	/*
		DeleteAllAccessTokensExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@return AccessTokenList

	*/
	DeleteAllAccessTokensExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*AccessTokenList, error)
	/*
		DeleteAllExpiredAccessTokens Deletes all expired access tokens
		Deletes all expired access tokens

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@return ApiDeleteAllExpiredAccessTokensRequest
	*/
	DeleteAllExpiredAccessTokens(ctx context.Context, projectId string, regionId string, instanceId string) ApiDeleteAllExpiredAccessTokensRequest
	/*
		DeleteAllExpiredAccessTokensExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@return AccessTokenList

	*/
	DeleteAllExpiredAccessTokensExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*AccessTokenList, error)
	/*
		DeleteLogsInstance Delete Logs instance
		Deletes the given Logs instance.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@return ApiDeleteLogsInstanceRequest
	*/
	DeleteLogsInstance(ctx context.Context, projectId string, regionId string, instanceId string) ApiDeleteLogsInstanceRequest
	/*
		DeleteLogsInstanceExecute executes the request

	*/
	DeleteLogsInstanceExecute(ctx context.Context, projectId string, regionId string, instanceId string) error
	/*
		GetAccessToken Get Access Token
		Get the information of the given access token.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@param tId The access token UUID.
		@return ApiGetAccessTokenRequest
	*/
	GetAccessToken(ctx context.Context, projectId string, regionId string, instanceId string, tId string) ApiGetAccessTokenRequest
	/*
		GetAccessTokenExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@param tId The access token UUID.
		@return AccessToken

	*/
	GetAccessTokenExecute(ctx context.Context, projectId string, regionId string, instanceId string, tId string) (*AccessToken, error)
	/*
		GetLogsInstance Get Logs Instance
		Returns the details for the given Logs instance.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@return ApiGetLogsInstanceRequest
	*/
	GetLogsInstance(ctx context.Context, projectId string, regionId string, instanceId string) ApiGetLogsInstanceRequest
	/*
		GetLogsInstanceExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@return LogsInstance

	*/
	GetLogsInstanceExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*LogsInstance, error)
	/*
		ListAccessTokens List Access Tokens
		Returns a list of access tokens created for a Logs instance

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@return ApiListAccessTokensRequest
	*/
	ListAccessTokens(ctx context.Context, projectId string, regionId string, instanceId string) ApiListAccessTokensRequest
	/*
		ListAccessTokensExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@return AccessTokenList

	*/
	ListAccessTokensExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*AccessTokenList, error)
	/*
		ListLogsInstances List Logs instances
		Returns a list of all Logs instances within the project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@return ApiListLogsInstancesRequest
	*/
	ListLogsInstances(ctx context.Context, projectId string, regionId string) ApiListLogsInstancesRequest
	/*
		ListLogsInstancesExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@return LogsInstancesList

	*/
	ListLogsInstancesExecute(ctx context.Context, projectId string, regionId string) (*LogsInstancesList, error)
	/*
		UpdateAccessToken Update Access Token
		Updates the given access token.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@param tId The access token UUID.
		@return ApiUpdateAccessTokenRequest
	*/
	UpdateAccessToken(ctx context.Context, projectId string, regionId string, instanceId string, tId string) ApiUpdateAccessTokenRequest
	/*
		UpdateAccessTokenExecute executes the request

	*/
	UpdateAccessTokenExecute(ctx context.Context, projectId string, regionId string, instanceId string, tId string) error
	/*
		UpdateLogsInstance Update Logs instance
		Updates the given Logs instance.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@return ApiUpdateLogsInstanceRequest
	*/
	UpdateLogsInstance(ctx context.Context, projectId string, regionId string, instanceId string) ApiUpdateLogsInstanceRequest
	/*
		UpdateLogsInstanceExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param instanceId The Logs Instance UUID.
		@return LogsInstance

	*/
	UpdateLogsInstanceExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*LogsInstance, error)
}

type ApiCreateAccessTokenRequest interface {
	CreateAccessTokenPayload(createAccessTokenPayload CreateAccessTokenPayload) ApiCreateAccessTokenRequest
	Execute() (*AccessToken, error)
}

type ApiCreateLogsInstanceRequest interface {
	CreateLogsInstancePayload(createLogsInstancePayload CreateLogsInstancePayload) ApiCreateLogsInstanceRequest
	Execute() (*LogsInstance, error)
}

type ApiDeleteAccessTokenRequest interface {
	Execute() error
}

type ApiDeleteAllAccessTokensRequest interface {
	Execute() (*AccessTokenList, error)
}

type ApiDeleteAllExpiredAccessTokensRequest interface {
	Execute() (*AccessTokenList, error)
}

type ApiDeleteLogsInstanceRequest interface {
	Execute() error
}

type ApiGetAccessTokenRequest interface {
	Execute() (*AccessToken, error)
}

type ApiGetLogsInstanceRequest interface {
	Execute() (*LogsInstance, error)
}

type ApiListAccessTokensRequest interface {
	Execute() (*AccessTokenList, error)
}

type ApiListLogsInstancesRequest interface {
	Execute() (*LogsInstancesList, error)
}

type ApiUpdateAccessTokenRequest interface {
	UpdateAccessTokenPayload(updateAccessTokenPayload UpdateAccessTokenPayload) ApiUpdateAccessTokenRequest
	Execute() error
}

type ApiUpdateLogsInstanceRequest interface {
	UpdateLogsInstancePayload(updateLogsInstancePayload UpdateLogsInstancePayload) ApiUpdateLogsInstanceRequest
	Execute() (*LogsInstance, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type CreateAccessTokenRequest struct {
	ctx                      context.Context
	apiService               *DefaultApiService
	projectId                string
	regionId                 string
	instanceId               string
	createAccessTokenPayload *CreateAccessTokenPayload
}

func (r CreateAccessTokenRequest) CreateAccessTokenPayload(createAccessTokenPayload CreateAccessTokenPayload) ApiCreateAccessTokenRequest {
	r.createAccessTokenPayload = &createAccessTokenPayload
	return r
}

func (r CreateAccessTokenRequest) Execute() (*AccessToken, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccessToken
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateAccessToken")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1alpha/projects/{projectId}/regions/{regionId}/instances/{instanceId}/access-tokens"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccessTokenPayload == nil {
		return localVarReturnValue, fmt.Errorf("createAccessTokenPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccessTokenPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateAccessToken: Create Access Token

Create a new Logs instance access token

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param instanceId The Logs Instance UUID.
	@return ApiCreateAccessTokenRequest
*/
func (a *APIClient) CreateAccessToken(ctx context.Context, projectId string, regionId string, instanceId string) ApiCreateAccessTokenRequest {
	return CreateAccessTokenRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
}

func (a *APIClient) CreateAccessTokenExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*AccessToken, error) {
	r := CreateAccessTokenRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
	return r.Execute()
}

type CreateLogsInstanceRequest struct {
	ctx                       context.Context
	apiService                *DefaultApiService
	projectId                 string
	regionId                  string
	createLogsInstancePayload *CreateLogsInstancePayload
}

func (r CreateLogsInstanceRequest) CreateLogsInstancePayload(createLogsInstancePayload CreateLogsInstancePayload) ApiCreateLogsInstanceRequest {
	r.createLogsInstancePayload = &createLogsInstancePayload
	return r
}

func (r CreateLogsInstanceRequest) Execute() (*LogsInstance, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LogsInstance
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateLogsInstance")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1alpha/projects/{projectId}/regions/{regionId}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogsInstancePayload == nil {
		return localVarReturnValue, fmt.Errorf("createLogsInstancePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createLogsInstancePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateLogsInstance: Create Logs instance

Creates a new Logs instance within the project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@return ApiCreateLogsInstanceRequest
*/
func (a *APIClient) CreateLogsInstance(ctx context.Context, projectId string, regionId string) ApiCreateLogsInstanceRequest {
	return CreateLogsInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
}

func (a *APIClient) CreateLogsInstanceExecute(ctx context.Context, projectId string, regionId string) (*LogsInstance, error) {
	r := CreateLogsInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
	return r.Execute()
}

type DeleteAccessTokenRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	instanceId string
	tId        string
}

func (r DeleteAccessTokenRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteAccessToken")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1alpha/projects/{projectId}/regions/{regionId}/instances/{instanceId}/access-tokens/{tId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tId"+"}", url.PathEscape(ParameterValueToString(r.tId, "tId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
DeleteAccessToken: Delete Access Token

Deletes a Logs instance access token

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param instanceId The Logs Instance UUID.
	@param tId The access token UUID.
	@return ApiDeleteAccessTokenRequest
*/
func (a *APIClient) DeleteAccessToken(ctx context.Context, projectId string, regionId string, instanceId string, tId string) ApiDeleteAccessTokenRequest {
	return DeleteAccessTokenRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
		tId:        tId,
	}
}

func (a *APIClient) DeleteAccessTokenExecute(ctx context.Context, projectId string, regionId string, instanceId string, tId string) error {
	r := DeleteAccessTokenRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
		tId:        tId,
	}
	return r.Execute()
}

type DeleteAllAccessTokensRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	instanceId string
}

func (r DeleteAllAccessTokensRequest) Execute() (*AccessTokenList, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccessTokenList
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteAllAccessTokens")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1alpha/projects/{projectId}/regions/{regionId}/instances/{instanceId}/access-tokens"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteAllAccessTokens: Delete All Access Tokens

Deletes all access tokens available for a Logs instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param instanceId The Logs Instance UUID.
	@return ApiDeleteAllAccessTokensRequest
*/
func (a *APIClient) DeleteAllAccessTokens(ctx context.Context, projectId string, regionId string, instanceId string) ApiDeleteAllAccessTokensRequest {
	return DeleteAllAccessTokensRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
}

func (a *APIClient) DeleteAllAccessTokensExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*AccessTokenList, error) {
	r := DeleteAllAccessTokensRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
	return r.Execute()
}

type DeleteAllExpiredAccessTokensRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	instanceId string
}

func (r DeleteAllExpiredAccessTokensRequest) Execute() (*AccessTokenList, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccessTokenList
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteAllExpiredAccessTokens")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1alpha/projects/{projectId}/regions/{regionId}/instances/{instanceId}/access-tokens/expired"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteAllExpiredAccessTokens: Deletes all expired access tokens

Deletes all expired access tokens

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param instanceId The Logs Instance UUID.
	@return ApiDeleteAllExpiredAccessTokensRequest
*/
func (a *APIClient) DeleteAllExpiredAccessTokens(ctx context.Context, projectId string, regionId string, instanceId string) ApiDeleteAllExpiredAccessTokensRequest {
	return DeleteAllExpiredAccessTokensRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
}

func (a *APIClient) DeleteAllExpiredAccessTokensExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*AccessTokenList, error) {
	r := DeleteAllExpiredAccessTokensRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
	return r.Execute()
}

type DeleteLogsInstanceRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	instanceId string
}

func (r DeleteLogsInstanceRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteLogsInstance")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1alpha/projects/{projectId}/regions/{regionId}/instances/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
DeleteLogsInstance: Delete Logs instance

Deletes the given Logs instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param instanceId The Logs Instance UUID.
	@return ApiDeleteLogsInstanceRequest
*/
func (a *APIClient) DeleteLogsInstance(ctx context.Context, projectId string, regionId string, instanceId string) ApiDeleteLogsInstanceRequest {
	return DeleteLogsInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
}

func (a *APIClient) DeleteLogsInstanceExecute(ctx context.Context, projectId string, regionId string, instanceId string) error {
	r := DeleteLogsInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
	return r.Execute()
}

type GetAccessTokenRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	instanceId string
	tId        string
}

func (r GetAccessTokenRequest) Execute() (*AccessToken, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccessToken
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAccessToken")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1alpha/projects/{projectId}/regions/{regionId}/instances/{instanceId}/access-tokens/{tId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tId"+"}", url.PathEscape(ParameterValueToString(r.tId, "tId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetAccessToken: Get Access Token

Get the information of the given access token.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param instanceId The Logs Instance UUID.
	@param tId The access token UUID.
	@return ApiGetAccessTokenRequest
*/
func (a *APIClient) GetAccessToken(ctx context.Context, projectId string, regionId string, instanceId string, tId string) ApiGetAccessTokenRequest {
	return GetAccessTokenRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
		tId:        tId,
	}
}

func (a *APIClient) GetAccessTokenExecute(ctx context.Context, projectId string, regionId string, instanceId string, tId string) (*AccessToken, error) {
	r := GetAccessTokenRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
		tId:        tId,
	}
	return r.Execute()
}

type GetLogsInstanceRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	instanceId string
}

func (r GetLogsInstanceRequest) Execute() (*LogsInstance, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LogsInstance
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetLogsInstance")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1alpha/projects/{projectId}/regions/{regionId}/instances/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetLogsInstance: Get Logs Instance

Returns the details for the given Logs instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param instanceId The Logs Instance UUID.
	@return ApiGetLogsInstanceRequest
*/
func (a *APIClient) GetLogsInstance(ctx context.Context, projectId string, regionId string, instanceId string) ApiGetLogsInstanceRequest {
	return GetLogsInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
}

func (a *APIClient) GetLogsInstanceExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*LogsInstance, error) {
	r := GetLogsInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
	return r.Execute()
}

type ListAccessTokensRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	instanceId string
}

func (r ListAccessTokensRequest) Execute() (*AccessTokenList, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccessTokenList
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListAccessTokens")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1alpha/projects/{projectId}/regions/{regionId}/instances/{instanceId}/access-tokens"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListAccessTokens: List Access Tokens

Returns a list of access tokens created for a Logs instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param instanceId The Logs Instance UUID.
	@return ApiListAccessTokensRequest
*/
func (a *APIClient) ListAccessTokens(ctx context.Context, projectId string, regionId string, instanceId string) ApiListAccessTokensRequest {
	return ListAccessTokensRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
}

func (a *APIClient) ListAccessTokensExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*AccessTokenList, error) {
	r := ListAccessTokensRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
	return r.Execute()
}

type ListLogsInstancesRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
}

func (r ListLogsInstancesRequest) Execute() (*LogsInstancesList, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LogsInstancesList
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListLogsInstances")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1alpha/projects/{projectId}/regions/{regionId}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListLogsInstances: List Logs instances

Returns a list of all Logs instances within the project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@return ApiListLogsInstancesRequest
*/
func (a *APIClient) ListLogsInstances(ctx context.Context, projectId string, regionId string) ApiListLogsInstancesRequest {
	return ListLogsInstancesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
}

func (a *APIClient) ListLogsInstancesExecute(ctx context.Context, projectId string, regionId string) (*LogsInstancesList, error) {
	r := ListLogsInstancesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
	return r.Execute()
}

type UpdateAccessTokenRequest struct {
	ctx                      context.Context
	apiService               *DefaultApiService
	projectId                string
	regionId                 string
	instanceId               string
	tId                      string
	updateAccessTokenPayload *UpdateAccessTokenPayload
}

func (r UpdateAccessTokenRequest) UpdateAccessTokenPayload(updateAccessTokenPayload UpdateAccessTokenPayload) ApiUpdateAccessTokenRequest {
	r.updateAccessTokenPayload = &updateAccessTokenPayload
	return r
}

func (r UpdateAccessTokenRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateAccessToken")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1alpha/projects/{projectId}/regions/{regionId}/instances/{instanceId}/access-tokens/{tId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tId"+"}", url.PathEscape(ParameterValueToString(r.tId, "tId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateAccessTokenPayload == nil {
		return fmt.Errorf("updateAccessTokenPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAccessTokenPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
UpdateAccessToken: Update Access Token

Updates the given access token.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param instanceId The Logs Instance UUID.
	@param tId The access token UUID.
	@return ApiUpdateAccessTokenRequest
*/
func (a *APIClient) UpdateAccessToken(ctx context.Context, projectId string, regionId string, instanceId string, tId string) ApiUpdateAccessTokenRequest {
	return UpdateAccessTokenRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
		tId:        tId,
	}
}

func (a *APIClient) UpdateAccessTokenExecute(ctx context.Context, projectId string, regionId string, instanceId string, tId string) error {
	r := UpdateAccessTokenRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
		tId:        tId,
	}
	return r.Execute()
}

type UpdateLogsInstanceRequest struct {
	ctx                       context.Context
	apiService                *DefaultApiService
	projectId                 string
	regionId                  string
	instanceId                string
	updateLogsInstancePayload *UpdateLogsInstancePayload
}

func (r UpdateLogsInstanceRequest) UpdateLogsInstancePayload(updateLogsInstancePayload UpdateLogsInstancePayload) ApiUpdateLogsInstanceRequest {
	r.updateLogsInstancePayload = &updateLogsInstancePayload
	return r
}

func (r UpdateLogsInstanceRequest) Execute() (*LogsInstance, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LogsInstance
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateLogsInstance")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1alpha/projects/{projectId}/regions/{regionId}/instances/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateLogsInstancePayload == nil {
		return localVarReturnValue, fmt.Errorf("updateLogsInstancePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateLogsInstancePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
UpdateLogsInstance: Update Logs instance

Updates the given Logs instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param instanceId The Logs Instance UUID.
	@return ApiUpdateLogsInstanceRequest
*/
func (a *APIClient) UpdateLogsInstance(ctx context.Context, projectId string, regionId string, instanceId string) ApiUpdateLogsInstanceRequest {
	return UpdateLogsInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
}

func (a *APIClient) UpdateLogsInstanceExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*LogsInstance, error) {
	r := UpdateLogsInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
	return r.Execute()
}
