/*
STACKIT Edge Cloud API

This API provides endpoints for managing STACKIT Edge Cloud instances.

API version: 1beta1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package edgebeta

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/stackitcloud/stackit-sdk-go/core/config"
	"github.com/stackitcloud/stackit-sdk-go/core/oapierror"
)

type DefaultApi interface {
	/*
		CreateInstance Method for CreateInstance
		Creates a new instance within the project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@return ApiCreateInstanceRequest
	*/
	CreateInstance(ctx context.Context, projectId string, regionId string) ApiCreateInstanceRequest
	/*
		CreateInstanceExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@return Instance

	*/
	CreateInstanceExecute(ctx context.Context, projectId string, regionId string) (*Instance, error)
	/*
		DeleteInstance Method for DeleteInstance
		Deletes the given instance.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@param instanceId The full ID of the instance, <display_name>-<project_hash>.
		@return ApiDeleteInstanceRequest
	*/
	DeleteInstance(ctx context.Context, projectId string, regionId string, instanceId string) ApiDeleteInstanceRequest
	/*
		DeleteInstanceExecute executes the request

	*/
	DeleteInstanceExecute(ctx context.Context, projectId string, regionId string, instanceId string) error
	/*
		DeleteInstanceByName Method for DeleteInstanceByName
		Deletes the given instance by name.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@param displayName The instance display name.
		@return ApiDeleteInstanceByNameRequest
	*/
	DeleteInstanceByName(ctx context.Context, projectId string, regionId string, displayName string) ApiDeleteInstanceByNameRequest
	/*
		DeleteInstanceByNameExecute executes the request

	*/
	DeleteInstanceByNameExecute(ctx context.Context, projectId string, regionId string, displayName string) error
	/*
		GetInstance Method for GetInstance
		Returns the details for the given instance.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@param instanceId The full ID of the instance, <display_name>-<project_hash>.
		@return ApiGetInstanceRequest
	*/
	GetInstance(ctx context.Context, projectId string, regionId string, instanceId string) ApiGetInstanceRequest
	/*
		GetInstanceExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@param instanceId The full ID of the instance, <display_name>-<project_hash>.
		@return Instance

	*/
	GetInstanceExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*Instance, error)
	/*
		GetInstanceByName Method for GetInstanceByName
		Returns the details for the given instance by name.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@param displayName The instance display name.
		@return ApiGetInstanceByNameRequest
	*/
	GetInstanceByName(ctx context.Context, projectId string, regionId string, displayName string) ApiGetInstanceByNameRequest
	/*
		GetInstanceByNameExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@param displayName The instance display name.
		@return Instance

	*/
	GetInstanceByNameExecute(ctx context.Context, projectId string, regionId string, displayName string) (*Instance, error)
	/*
		GetKubeconfigByInstanceId Method for GetKubeconfigByInstanceId
		Returns the kubeconfig for the given instance.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@param instanceId The full ID of the instance, <display_name>-<project_hash>.
		@return ApiGetKubeconfigByInstanceIdRequest
	*/
	GetKubeconfigByInstanceId(ctx context.Context, projectId string, regionId string, instanceId string) ApiGetKubeconfigByInstanceIdRequest
	/*
		GetKubeconfigByInstanceIdExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@param instanceId The full ID of the instance, <display_name>-<project_hash>.
		@return Kubeconfig

	*/
	GetKubeconfigByInstanceIdExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*Kubeconfig, error)
	/*
		GetKubeconfigByInstanceName Method for GetKubeconfigByInstanceName
		Returns the kubeconfig for the given instance.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@param displayName The instance display name.
		@return ApiGetKubeconfigByInstanceNameRequest
	*/
	GetKubeconfigByInstanceName(ctx context.Context, projectId string, regionId string, displayName string) ApiGetKubeconfigByInstanceNameRequest
	/*
		GetKubeconfigByInstanceNameExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@param displayName The instance display name.
		@return Kubeconfig

	*/
	GetKubeconfigByInstanceNameExecute(ctx context.Context, projectId string, regionId string, displayName string) (*Kubeconfig, error)
	/*
		GetTokenByInstanceId Method for GetTokenByInstanceId
		Returns an ServiceAccount token.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@param instanceId The instance UUID.
		@return ApiGetTokenByInstanceIdRequest
	*/
	GetTokenByInstanceId(ctx context.Context, projectId string, regionId string, instanceId string) ApiGetTokenByInstanceIdRequest
	/*
		GetTokenByInstanceIdExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@param instanceId The instance UUID.
		@return Token

	*/
	GetTokenByInstanceIdExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*Token, error)
	/*
		GetTokenByInstanceName Method for GetTokenByInstanceName
		Returns an ServiceAccount token.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@param displayName The instance display name.
		@return ApiGetTokenByInstanceNameRequest
	*/
	GetTokenByInstanceName(ctx context.Context, projectId string, regionId string, displayName string) ApiGetTokenByInstanceNameRequest
	/*
		GetTokenByInstanceNameExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@param displayName The instance display name.
		@return Token

	*/
	GetTokenByInstanceNameExecute(ctx context.Context, projectId string, regionId string, displayName string) (*Token, error)
	/*
		ListInstances Method for ListInstances
		Returns a list of all instances within the project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@return ApiListInstancesRequest
	*/
	ListInstances(ctx context.Context, projectId string, regionId string) ApiListInstancesRequest
	/*
		ListInstancesExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@return InstanceList

	*/
	ListInstancesExecute(ctx context.Context, projectId string, regionId string) (*InstanceList, error)
	/*
		ListPlansGlobal Method for ListPlansGlobal
		Deprecated: DEPRECATED: Will be removed at the 28 of february 2026. Use list-plans-project instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListPlansGlobalRequest
	*/
	ListPlansGlobal(ctx context.Context) ApiListPlansGlobalRequest
	/*
		ListPlansGlobalExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return PlanList

		Deprecated: DEPRECATED: Will be removed at the 28 of february 2026. Use list-plans-project instead.
	*/
	ListPlansGlobalExecute(ctx context.Context) (*PlanList, error)
	/*
		ListPlansProject Method for ListPlansProject
		List all possible plans for the project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the plan is part of.
		@return ApiListPlansProjectRequest
	*/
	ListPlansProject(ctx context.Context, projectId string) ApiListPlansProjectRequest
	/*
		ListPlansProjectExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the plan is part of.
		@return PlanList

	*/
	ListPlansProjectExecute(ctx context.Context, projectId string) (*PlanList, error)
	/*
		UpdateInstance Method for UpdateInstance
		Updates the given instance.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@param instanceId The full ID of the instance, <display_name>-<project_hash>.
		@return ApiUpdateInstanceRequest
	*/
	UpdateInstance(ctx context.Context, projectId string, regionId string, instanceId string) ApiUpdateInstanceRequest
	/*
		UpdateInstanceExecute executes the request

	*/
	UpdateInstanceExecute(ctx context.Context, projectId string, regionId string, instanceId string) error
	/*
		UpdateInstanceByName Method for UpdateInstanceByName
		Updates the given instance.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the instance is part of.
		@param regionId The STACKIT region the instance is part of.
		@param displayName The instance display name.
		@return ApiUpdateInstanceByNameRequest
	*/
	UpdateInstanceByName(ctx context.Context, projectId string, regionId string, displayName string) ApiUpdateInstanceByNameRequest
	/*
		UpdateInstanceByNameExecute executes the request

	*/
	UpdateInstanceByNameExecute(ctx context.Context, projectId string, regionId string, displayName string) error
}

type ApiCreateInstanceRequest interface {
	CreateInstancePayload(createInstancePayload CreateInstancePayload) ApiCreateInstanceRequest
	Execute() (*Instance, error)
}

type ApiDeleteInstanceRequest interface {
	Execute() error
}

type ApiDeleteInstanceByNameRequest interface {
	Execute() error
}

type ApiGetInstanceRequest interface {
	Execute() (*Instance, error)
}

type ApiGetInstanceByNameRequest interface {
	Execute() (*Instance, error)
}

type ApiGetKubeconfigByInstanceIdRequest interface {
	// Expiration of the included token in seconds
	ExpirationSeconds(expirationSeconds int64) ApiGetKubeconfigByInstanceIdRequest
	Execute() (*Kubeconfig, error)
}

type ApiGetKubeconfigByInstanceNameRequest interface {
	// Expiration of the included token in seconds
	ExpirationSeconds(expirationSeconds int64) ApiGetKubeconfigByInstanceNameRequest
	Execute() (*Kubeconfig, error)
}

type ApiGetTokenByInstanceIdRequest interface {
	// Expiration of the token in seconds
	ExpirationSeconds(expirationSeconds int64) ApiGetTokenByInstanceIdRequest
	Execute() (*Token, error)
}

type ApiGetTokenByInstanceNameRequest interface {
	// Expiration of the included token in seconds
	ExpirationSeconds(expirationSeconds int64) ApiGetTokenByInstanceNameRequest
	Execute() (*Token, error)
}

type ApiListInstancesRequest interface {
	Execute() (*InstanceList, error)
}

type ApiListPlansGlobalRequest interface {
	Execute() (*PlanList, error)
}

type ApiListPlansProjectRequest interface {
	Execute() (*PlanList, error)
}

type ApiUpdateInstanceRequest interface {
	UpdateInstancePayload(updateInstancePayload UpdateInstancePayload) ApiUpdateInstanceRequest
	Execute() error
}

type ApiUpdateInstanceByNameRequest interface {
	UpdateInstanceByNamePayload(updateInstanceByNamePayload UpdateInstanceByNamePayload) ApiUpdateInstanceByNameRequest
	Execute() error
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type CreateInstanceRequest struct {
	ctx                   context.Context
	apiService            *DefaultApiService
	projectId             string
	regionId              string
	createInstancePayload *CreateInstancePayload
}

func (r CreateInstanceRequest) CreateInstancePayload(createInstancePayload CreateInstancePayload) ApiCreateInstanceRequest {
	r.createInstancePayload = &createInstancePayload
	return r
}

func (r CreateInstanceRequest) Execute() (*Instance, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Instance
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateInstance")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/projects/{projectId}/regions/{regionId}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createInstancePayload == nil {
		return localVarReturnValue, fmt.Errorf("createInstancePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createInstancePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateInstance: Method for CreateInstance

Creates a new instance within the project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the instance is part of.
	@param regionId The STACKIT region the instance is part of.
	@return ApiCreateInstanceRequest
*/
func (a *APIClient) CreateInstance(ctx context.Context, projectId string, regionId string) ApiCreateInstanceRequest {
	return CreateInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
}

func (a *APIClient) CreateInstanceExecute(ctx context.Context, projectId string, regionId string) (*Instance, error) {
	r := CreateInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
	return r.Execute()
}

type DeleteInstanceRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	instanceId string
}

func (r DeleteInstanceRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteInstance")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/projects/{projectId}/regions/{regionId}/instances/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.instanceId) > 16 {
		return fmt.Errorf("instanceId must have less than 16 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
DeleteInstance: Method for DeleteInstance

Deletes the given instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the instance is part of.
	@param regionId The STACKIT region the instance is part of.
	@param instanceId The full ID of the instance, <display_name>-<project_hash>.
	@return ApiDeleteInstanceRequest
*/
func (a *APIClient) DeleteInstance(ctx context.Context, projectId string, regionId string, instanceId string) ApiDeleteInstanceRequest {
	return DeleteInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
}

func (a *APIClient) DeleteInstanceExecute(ctx context.Context, projectId string, regionId string, instanceId string) error {
	r := DeleteInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
	return r.Execute()
}

type DeleteInstanceByNameRequest struct {
	ctx         context.Context
	apiService  *DefaultApiService
	projectId   string
	regionId    string
	displayName string
}

func (r DeleteInstanceByNameRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteInstanceByName")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/projects/{projectId}/regions/{regionId}/instancesbyname/{displayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"displayName"+"}", url.PathEscape(ParameterValueToString(r.displayName, "displayName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.displayName) > 8 {
		return fmt.Errorf("displayName must have less than 8 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
DeleteInstanceByName: Method for DeleteInstanceByName

Deletes the given instance by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the instance is part of.
	@param regionId The STACKIT region the instance is part of.
	@param displayName The instance display name.
	@return ApiDeleteInstanceByNameRequest
*/
func (a *APIClient) DeleteInstanceByName(ctx context.Context, projectId string, regionId string, displayName string) ApiDeleteInstanceByNameRequest {
	return DeleteInstanceByNameRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		projectId:   projectId,
		regionId:    regionId,
		displayName: displayName,
	}
}

func (a *APIClient) DeleteInstanceByNameExecute(ctx context.Context, projectId string, regionId string, displayName string) error {
	r := DeleteInstanceByNameRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		projectId:   projectId,
		regionId:    regionId,
		displayName: displayName,
	}
	return r.Execute()
}

type GetInstanceRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	instanceId string
}

func (r GetInstanceRequest) Execute() (*Instance, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Instance
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetInstance")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/projects/{projectId}/regions/{regionId}/instances/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.instanceId) > 16 {
		return localVarReturnValue, fmt.Errorf("instanceId must have less than 16 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetInstance: Method for GetInstance

Returns the details for the given instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the instance is part of.
	@param regionId The STACKIT region the instance is part of.
	@param instanceId The full ID of the instance, <display_name>-<project_hash>.
	@return ApiGetInstanceRequest
*/
func (a *APIClient) GetInstance(ctx context.Context, projectId string, regionId string, instanceId string) ApiGetInstanceRequest {
	return GetInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
}

func (a *APIClient) GetInstanceExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*Instance, error) {
	r := GetInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
	return r.Execute()
}

type GetInstanceByNameRequest struct {
	ctx         context.Context
	apiService  *DefaultApiService
	projectId   string
	regionId    string
	displayName string
}

func (r GetInstanceByNameRequest) Execute() (*Instance, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Instance
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetInstanceByName")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/projects/{projectId}/regions/{regionId}/instancesbyname/{displayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"displayName"+"}", url.PathEscape(ParameterValueToString(r.displayName, "displayName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.displayName) > 8 {
		return localVarReturnValue, fmt.Errorf("displayName must have less than 8 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetInstanceByName: Method for GetInstanceByName

Returns the details for the given instance by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the instance is part of.
	@param regionId The STACKIT region the instance is part of.
	@param displayName The instance display name.
	@return ApiGetInstanceByNameRequest
*/
func (a *APIClient) GetInstanceByName(ctx context.Context, projectId string, regionId string, displayName string) ApiGetInstanceByNameRequest {
	return GetInstanceByNameRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		projectId:   projectId,
		regionId:    regionId,
		displayName: displayName,
	}
}

func (a *APIClient) GetInstanceByNameExecute(ctx context.Context, projectId string, regionId string, displayName string) (*Instance, error) {
	r := GetInstanceByNameRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		projectId:   projectId,
		regionId:    regionId,
		displayName: displayName,
	}
	return r.Execute()
}

type GetKubeconfigByInstanceIdRequest struct {
	ctx               context.Context
	apiService        *DefaultApiService
	projectId         string
	regionId          string
	instanceId        string
	expirationSeconds *int64
}

// Expiration of the included token in seconds

func (r GetKubeconfigByInstanceIdRequest) ExpirationSeconds(expirationSeconds int64) ApiGetKubeconfigByInstanceIdRequest {
	r.expirationSeconds = &expirationSeconds
	return r
}

func (r GetKubeconfigByInstanceIdRequest) Execute() (*Kubeconfig, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Kubeconfig
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetKubeconfigByInstanceId")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/projects/{projectId}/regions/{regionId}/instances/{instanceId}/kubeconfig"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.instanceId) > 16 {
		return localVarReturnValue, fmt.Errorf("instanceId must have less than 16 elements")
	}

	if r.expirationSeconds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationSeconds", r.expirationSeconds, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetKubeconfigByInstanceId: Method for GetKubeconfigByInstanceId

Returns the kubeconfig for the given instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the instance is part of.
	@param regionId The STACKIT region the instance is part of.
	@param instanceId The full ID of the instance, <display_name>-<project_hash>.
	@return ApiGetKubeconfigByInstanceIdRequest
*/
func (a *APIClient) GetKubeconfigByInstanceId(ctx context.Context, projectId string, regionId string, instanceId string) ApiGetKubeconfigByInstanceIdRequest {
	return GetKubeconfigByInstanceIdRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
}

func (a *APIClient) GetKubeconfigByInstanceIdExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*Kubeconfig, error) {
	r := GetKubeconfigByInstanceIdRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
	return r.Execute()
}

type GetKubeconfigByInstanceNameRequest struct {
	ctx               context.Context
	apiService        *DefaultApiService
	projectId         string
	regionId          string
	displayName       string
	expirationSeconds *int64
}

// Expiration of the included token in seconds

func (r GetKubeconfigByInstanceNameRequest) ExpirationSeconds(expirationSeconds int64) ApiGetKubeconfigByInstanceNameRequest {
	r.expirationSeconds = &expirationSeconds
	return r
}

func (r GetKubeconfigByInstanceNameRequest) Execute() (*Kubeconfig, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Kubeconfig
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetKubeconfigByInstanceName")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/projects/{projectId}/regions/{regionId}/instancesbyname/{displayName}/kubeconfig"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"displayName"+"}", url.PathEscape(ParameterValueToString(r.displayName, "displayName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.displayName) > 8 {
		return localVarReturnValue, fmt.Errorf("displayName must have less than 8 elements")
	}

	if r.expirationSeconds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationSeconds", r.expirationSeconds, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetKubeconfigByInstanceName: Method for GetKubeconfigByInstanceName

Returns the kubeconfig for the given instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the instance is part of.
	@param regionId The STACKIT region the instance is part of.
	@param displayName The instance display name.
	@return ApiGetKubeconfigByInstanceNameRequest
*/
func (a *APIClient) GetKubeconfigByInstanceName(ctx context.Context, projectId string, regionId string, displayName string) ApiGetKubeconfigByInstanceNameRequest {
	return GetKubeconfigByInstanceNameRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		projectId:   projectId,
		regionId:    regionId,
		displayName: displayName,
	}
}

func (a *APIClient) GetKubeconfigByInstanceNameExecute(ctx context.Context, projectId string, regionId string, displayName string) (*Kubeconfig, error) {
	r := GetKubeconfigByInstanceNameRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		projectId:   projectId,
		regionId:    regionId,
		displayName: displayName,
	}
	return r.Execute()
}

type GetTokenByInstanceIdRequest struct {
	ctx               context.Context
	apiService        *DefaultApiService
	projectId         string
	regionId          string
	instanceId        string
	expirationSeconds *int64
}

// Expiration of the token in seconds

func (r GetTokenByInstanceIdRequest) ExpirationSeconds(expirationSeconds int64) ApiGetTokenByInstanceIdRequest {
	r.expirationSeconds = &expirationSeconds
	return r
}

func (r GetTokenByInstanceIdRequest) Execute() (*Token, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Token
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTokenByInstanceId")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/projects/{projectId}/regions/{regionId}/instances/{instanceId}/token"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.instanceId) > 16 {
		return localVarReturnValue, fmt.Errorf("instanceId must have less than 16 elements")
	}

	if r.expirationSeconds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationSeconds", r.expirationSeconds, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetTokenByInstanceId: Method for GetTokenByInstanceId

Returns an ServiceAccount token.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the instance is part of.
	@param regionId The STACKIT region the instance is part of.
	@param instanceId The instance UUID.
	@return ApiGetTokenByInstanceIdRequest
*/
func (a *APIClient) GetTokenByInstanceId(ctx context.Context, projectId string, regionId string, instanceId string) ApiGetTokenByInstanceIdRequest {
	return GetTokenByInstanceIdRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
}

func (a *APIClient) GetTokenByInstanceIdExecute(ctx context.Context, projectId string, regionId string, instanceId string) (*Token, error) {
	r := GetTokenByInstanceIdRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
	return r.Execute()
}

type GetTokenByInstanceNameRequest struct {
	ctx               context.Context
	apiService        *DefaultApiService
	projectId         string
	regionId          string
	displayName       string
	expirationSeconds *int64
}

// Expiration of the included token in seconds

func (r GetTokenByInstanceNameRequest) ExpirationSeconds(expirationSeconds int64) ApiGetTokenByInstanceNameRequest {
	r.expirationSeconds = &expirationSeconds
	return r
}

func (r GetTokenByInstanceNameRequest) Execute() (*Token, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Token
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTokenByInstanceName")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/projects/{projectId}/regions/{regionId}/instancesbyname/{displayName}/token"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"displayName"+"}", url.PathEscape(ParameterValueToString(r.displayName, "displayName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.displayName) > 8 {
		return localVarReturnValue, fmt.Errorf("displayName must have less than 8 elements")
	}

	if r.expirationSeconds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationSeconds", r.expirationSeconds, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetTokenByInstanceName: Method for GetTokenByInstanceName

Returns an ServiceAccount token.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the instance is part of.
	@param regionId The STACKIT region the instance is part of.
	@param displayName The instance display name.
	@return ApiGetTokenByInstanceNameRequest
*/
func (a *APIClient) GetTokenByInstanceName(ctx context.Context, projectId string, regionId string, displayName string) ApiGetTokenByInstanceNameRequest {
	return GetTokenByInstanceNameRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		projectId:   projectId,
		regionId:    regionId,
		displayName: displayName,
	}
}

func (a *APIClient) GetTokenByInstanceNameExecute(ctx context.Context, projectId string, regionId string, displayName string) (*Token, error) {
	r := GetTokenByInstanceNameRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		projectId:   projectId,
		regionId:    regionId,
		displayName: displayName,
	}
	return r.Execute()
}

type ListInstancesRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
}

func (r ListInstancesRequest) Execute() (*InstanceList, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InstanceList
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListInstances")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/projects/{projectId}/regions/{regionId}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListInstances: Method for ListInstances

Returns a list of all instances within the project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the instance is part of.
	@param regionId The STACKIT region the instance is part of.
	@return ApiListInstancesRequest
*/
func (a *APIClient) ListInstances(ctx context.Context, projectId string, regionId string) ApiListInstancesRequest {
	return ListInstancesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
}

func (a *APIClient) ListInstancesExecute(ctx context.Context, projectId string, regionId string) (*InstanceList, error) {
	r := ListInstancesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
	return r.Execute()
}

type ListPlansGlobalRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
}

func (r ListPlansGlobalRequest) Execute() (*PlanList, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PlanList
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListPlansGlobal")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListPlansGlobal: Method for ListPlansGlobal

Deprecated: DEPRECATED: Will be removed at the 28 of february 2026. Use list-plans-project instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListPlansGlobalRequest
*/
func (a *APIClient) ListPlansGlobal(ctx context.Context) ApiListPlansGlobalRequest {
	return ListPlansGlobalRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
}

/*
Deprecated: DEPRECATED: Will be removed at the 28 of february 2026. Use list-plans-project instead.
*/
func (a *APIClient) ListPlansGlobalExecute(ctx context.Context) (*PlanList, error) {
	r := ListPlansGlobalRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
	return r.Execute()
}

type ListPlansProjectRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
}

func (r ListPlansProjectRequest) Execute() (*PlanList, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PlanList
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListPlansProject")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/projects/{projectId}/plans"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListPlansProject: Method for ListPlansProject

List all possible plans for the project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the plan is part of.
	@return ApiListPlansProjectRequest
*/
func (a *APIClient) ListPlansProject(ctx context.Context, projectId string) ApiListPlansProjectRequest {
	return ListPlansProjectRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) ListPlansProjectExecute(ctx context.Context, projectId string) (*PlanList, error) {
	r := ListPlansProjectRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type UpdateInstanceRequest struct {
	ctx                   context.Context
	apiService            *DefaultApiService
	projectId             string
	regionId              string
	instanceId            string
	updateInstancePayload *UpdateInstancePayload
}

func (r UpdateInstanceRequest) UpdateInstancePayload(updateInstancePayload UpdateInstancePayload) ApiUpdateInstanceRequest {
	r.updateInstancePayload = &updateInstancePayload
	return r
}

func (r UpdateInstanceRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateInstance")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/projects/{projectId}/regions/{regionId}/instances/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.instanceId) > 16 {
		return fmt.Errorf("instanceId must have less than 16 elements")
	}
	if r.updateInstancePayload == nil {
		return fmt.Errorf("updateInstancePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateInstancePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
UpdateInstance: Method for UpdateInstance

Updates the given instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the instance is part of.
	@param regionId The STACKIT region the instance is part of.
	@param instanceId The full ID of the instance, <display_name>-<project_hash>.
	@return ApiUpdateInstanceRequest
*/
func (a *APIClient) UpdateInstance(ctx context.Context, projectId string, regionId string, instanceId string) ApiUpdateInstanceRequest {
	return UpdateInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
}

func (a *APIClient) UpdateInstanceExecute(ctx context.Context, projectId string, regionId string, instanceId string) error {
	r := UpdateInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		instanceId: instanceId,
	}
	return r.Execute()
}

type UpdateInstanceByNameRequest struct {
	ctx                         context.Context
	apiService                  *DefaultApiService
	projectId                   string
	regionId                    string
	displayName                 string
	updateInstanceByNamePayload *UpdateInstanceByNamePayload
}

func (r UpdateInstanceByNameRequest) UpdateInstanceByNamePayload(updateInstanceByNamePayload UpdateInstanceByNamePayload) ApiUpdateInstanceByNameRequest {
	r.updateInstanceByNamePayload = &updateInstanceByNamePayload
	return r
}

func (r UpdateInstanceByNameRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateInstanceByName")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/projects/{projectId}/regions/{regionId}/instancesbyname/{displayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"displayName"+"}", url.PathEscape(ParameterValueToString(r.displayName, "displayName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.displayName) > 8 {
		return fmt.Errorf("displayName must have less than 8 elements")
	}
	if r.updateInstanceByNamePayload == nil {
		return fmt.Errorf("updateInstanceByNamePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateInstanceByNamePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedRequest
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
UpdateInstanceByName: Method for UpdateInstanceByName

Updates the given instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the instance is part of.
	@param regionId The STACKIT region the instance is part of.
	@param displayName The instance display name.
	@return ApiUpdateInstanceByNameRequest
*/
func (a *APIClient) UpdateInstanceByName(ctx context.Context, projectId string, regionId string, displayName string) ApiUpdateInstanceByNameRequest {
	return UpdateInstanceByNameRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		projectId:   projectId,
		regionId:    regionId,
		displayName: displayName,
	}
}

func (a *APIClient) UpdateInstanceByNameExecute(ctx context.Context, projectId string, regionId string, displayName string) error {
	r := UpdateInstanceByNameRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		projectId:   projectId,
		regionId:    regionId,
		displayName: displayName,
	}
	return r.Execute()
}
